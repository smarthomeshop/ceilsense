# CeilSense v1 - shared base for all variants

substitutions:
  wifi_fast_connect: "true"
  device_name: "ceilsense"
  friendly_name: "CeilSense"
  project_name: "smarthomeshop.ceilsense"
  project_main_version: "1.26"
  project_version: "1.26"
  ceilsense_hardware_version: "v1"
  build_variant: "ceilsense"
  log_level: "INFO"
  # Default manifests (overridden by variants)
  wifi_update_manifest_url: "https://smarthomeshop.github.io/ceilsense/ceilsense-basic-wifi-manifest.json"
  eth_update_manifest_url: "https://smarthomeshop.github.io/ceilsense/ceilsense-basic-eth-manifest.json"
  default_network: "WiFi"
  i2c_frequency: "400kHz"

esphome:
  name: ${device_name}
  friendly_name: ${friendly_name}
  name_add_mac_suffix: true
  project:
    name: ${project_name}
    version: ${project_version}
  build_path: build/${build_variant}
  on_boot:
    - priority: 610
      then:
        - if:
            condition:
              lambda: 'return std::string("${default_network}") == std::string("Ethernet");'
            then:
              - logger.log: "OTA updates set to use ethernet firmware"
              - lambda: 'id(firmware_update).set_source_url("${eth_update_manifest_url}");'
              - component.update: firmware_update
            else:
              - logger.log: "OTA updates set to use wifi firmware"
              - lambda: 'id(firmware_update).set_source_url("${wifi_update_manifest_url}");'
              - component.update: firmware_update
    - priority: 540
      then:
        # Fase 4: BH1750 lux
        - lambda: |-
            id(startup_phase) = 4;
        - wait_until:
            condition:
              lambda: |-
                return id(illuminance).has_state() && !isnan(id(illuminance).state);
            timeout: 30s
        - if:
            condition:
              lambda: |-
                return !id(illuminance).has_state() || isnan(id(illuminance).state);
            then:
              - lambda: |-
                  id(startup_failed) = true;
        # Fase 5: BMP3xx druk
        - lambda: |-
            id(startup_phase) = 5;
        - wait_until:
            condition:
              lambda: |-
                return id(bmp_pressure).has_state() && !isnan(id(bmp_pressure).state);
            timeout: 30s
        - if:
            condition:
              lambda: |-
                return !id(bmp_pressure).has_state() || isnan(id(bmp_pressure).state);
            then:
              - lambda: |-
                  id(startup_failed) = true;
        # Finale indicatie en afronden (wacht op verplichte checks)
        - wait_until:
            condition:
              lambda: |-
                const bool ld2412_ok = !id(ld2412_required) || id(ld2412_checked);
                const bool ld2450_ok = !id(ld2450_required) || id(ld2450_checked);
                const bool scd4x_ok = !id(scd4x_required) || id(scd4x_checked);
                return ld2412_ok && ld2450_ok && scd4x_ok;
            timeout: 120s
        - light.turn_off: status_led
        - if:
            condition:
              lambda: |-
                return !id(startup_failed);
            then:
              - light.turn_on:
                  id: status_led
                  brightness: 100%
                  red: 100%
                  green: 100%
                  blue: 100%
                  transition_length: 1s
              - delay: 3s
              - light.turn_off:
                  id: status_led
                  transition_length: 1s
            else:
              - light.turn_on:
                  id: status_led
                  brightness: 100%
                  red: 100%
                  green: 0%
                  blue: 0%
                  transition_length: 200ms
              - delay: 20s
              - light.turn_off:
                  id: status_led
                  transition_length: 300ms

esp32:
  board: esp32-s3-devkitc-1
  framework:
    type: esp-idf

logger:
  level: ${log_level}
  baud_rate: 115200
  hardware_uart: UART0
  
api:
ota:
  - platform: esphome
    id: ota_esphome
  - platform: http_request
    id: ota_http_request

# Enable ESPHome debug component
debug:
  update_interval: 15min

# Globals
globals:
  - id: startup_phase
    type: int
    restore_value: no
    initial_value: '0'
  - id: startup_failed
    type: bool
    restore_value: no
    initial_value: "false"
  - id: onboarding_sent
    type: bool
    restore_value: yes
    initial_value: "false"
  - id: ld2412_required
    type: bool
    restore_value: no
    initial_value: "false"
  - id: scd4x_required
    type: bool
    restore_value: no
    initial_value: "false"
  - id: ld2412_checked
    type: bool
    restore_value: no
    initial_value: "false"
  - id: scd4x_checked
    type: bool
    restore_value: no
    initial_value: "false"
  - id: ld2450_required
    type: bool
    restore_value: no
    initial_value: "false"
  - id: ld2450_checked
    type: bool
    restore_value: no
    initial_value: "false"
  - id: dbg_last_dist_m
    type: float
    restore_value: no
    initial_value: "0.0"
  - id: dbg_smooth_dist_m
    type: float
    restore_value: no
    initial_value: "0.0"
  - id: dbg_last_leds
    type: int
    restore_value: no
    initial_value: '0'

# Optional components toggled by packages
# Sensors (optional modules via packages)
# UART and LD2412 are added via package only in LD2412 variants

light:
  - platform: esp32_rmt_led_strip
    rgb_order: GRB
    pin: GPIO20
    num_leds: 16
    chipset: ws2812
    id: status_led
    name: "CeilSense Status LED"
    restore_mode: ALWAYS_OFF
    default_transition_length: 0s
    effects:
      - addressable_lambda:
          name: "Circular Loading Effect"
          update_interval: 100ms
          lambda: |-
            static int pos = 0;
            const int tail_length = 2;
            const float brightness_step = 1.0 / (tail_length + 1);
            it.all() = esphome::Color(0, 0, 0);
            esphome::Color headColor(0, 0, 255);
            switch (id(startup_phase)) {
              case 1: headColor = esphome::Color(0, 255, 255); break;
              case 2: headColor = esphome::Color(255, 0, 255); break;
              case 3: headColor = esphome::Color(0, 255, 0); break;
              case 4: headColor = esphome::Color(255, 128, 0); break;
              default: headColor = esphome::Color(0, 0, 255); break;
            }
            it[pos] = headColor;
            for (int i = 1; i <= tail_length; i++) {
              float brightness = 1.0 - (i * brightness_step);
              int index = (pos - i + it.size()) % it.size();
              auto color = headColor;
              color.red = static_cast<uint8_t>(color.red * brightness);
              color.green = static_cast<uint8_t>(color.green * brightness);
              color.blue = static_cast<uint8_t>(color.blue * brightness);
              it[index] = color;
            }
            pos = (pos + 1) % it.size();

web_server:
  port: 80

# Update entity placeholder (point to your manifest later via substitutions)
http_request:
  useragent: ceilsense-esphome
update:
  - platform: http_request
    name: CeilSense Firmware
    id: firmware_update
    source: ${wifi_update_manifest_url}

# I2C + sensors
i2c:
  sda: GPIO11
  scl: GPIO10
  scan: true
  id: bus_a
  frequency: ${i2c_frequency}

sensor:
  - platform: internal_temperature
    name: "CPU Temperature"
    id: cpu_temperature
  - platform: bh1750
    name: "BH1750 Illuminance"
    id: illuminance
    address: 0x23
    update_interval: 60s
  - platform: bmp3xx_i2c
    temperature:
      name: "BMP3xx Temperature"
      id: bmp_temperature
    pressure:
      name: "BMP3xx Pressure"
      id: bmp_pressure
    address: 0x76
    update_interval: 60s

# Buttons & switches
switch:
  - platform: template
    name: "LD2412 Debug Mode"
    id: debug_mode
    optimistic: true
    restore_mode: RESTORE_DEFAULT_OFF
  - platform: template
    name: "Disable Bluetooth after boot"
    id: ble_disable_after_boot
    icon: mdi:bluetooth-off
    optimistic: true
    restore_mode: RESTORE_DEFAULT_ON

button:
  - platform: restart
    name: "Restart Device"
    id: btn_restart
  - platform: factory_reset
    id: factory_reset_button
    name: "Factory Reset"
    entity_category: config
    disabled_by_default: true

# Firmware type selector (WiFi / Ethernet)
select:
  - platform: template
    id: firmware_selector
    name: Firmware Type
    icon: "mdi:test-tube"
    entity_category: config
    optimistic: true
    restore_value: true
    options:
      - "WiFi"
      - "Ethernet"
    initial_option: ${default_network}
    on_value:
      then:
        - if:
            condition:
              lambda: 'return id(firmware_selector).state == "Ethernet";'
            then:
              - logger.log: "OTA updates set to use ethernet firmware"
              - lambda: 'id(firmware_update).set_source_url("${eth_update_manifest_url}");'
              - component.update: firmware_update
            else:
              - logger.log: "OTA updates set to use wifi firmware"
              - lambda: 'id(firmware_update).set_source_url("${wifi_update_manifest_url}");'
              - component.update: firmware_update

# Text sensors
text_sensor:
  - platform: debug
    device:
      name: "Device Info"
    reset_reason:
      name: "ESP Reset Reason"
      id: esp_reset_reason_text
      icon: mdi:anchor
      disabled_by_default: True
      entity_category: diagnostic
  - platform: template
    id: ceilsense_software_version_text
    name: "Software Version"
    update_interval: 5h
    lambda: |-
      return {"${project_version}"};
  - platform: template
    id: ceilsense_hardware_version_text
    name: "Hardware Version"
    update_interval: 5h
    lambda: |-
      return {"${ceilsense_hardware_version}"};

# Script placeholder
script:
  - id: play_stream
    then:
      - delay: 10ms
